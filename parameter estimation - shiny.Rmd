---
title: "Parameter Estimation"
author: "Johanna Daas"
date: "5 12 2020"
output: html_document
runtime: shiny
toc_float: TRUE
---
```{r, echo = FALSE}
library(CoRC)
library(tidyverse, verbose = FALSE, quietly = TRUE, suppressPackageStartupMessages())
```
# Introduction
In this workflow we will show you an implementation of a parameter estimation on the [Mendes 2009 paper](https://doi.org/10.1007/978-1-59745-525-1_2) on **COPASI** use cases.

You can see a *Timecourse* of the species of the model below. The points are measurements of two of the species in the model.
```{r, echo = FALSE}
data <- read.table("MAPKdata1.txt", header = TRUE)
loadSBML("https://www.ebi.ac.uk/biomodels/model/download/BIOMD0000000010.2?filename=BIOMD0000000010_url.xml") 


param_before <- getParameters()$value
vs <- which(substr(getParameters()$name,1,1) == "V")


fluidRow(
    
    column(2,    
    sliderInput("V1",
              label = as.character(getParameters()$key[vs[1]]),
              min = 0.1 * getParameters()$value[vs[1]],
              max = 1.9 * getParameters()$value[vs[1]],
              value = getParameters()$value[vs[1]],
              step = 0.1),
    
    sliderInput("V2",
              label = as.character(getParameters()$key[vs[2]]),
              min = 0.1 * getParameters()$value[vs[2]],
              max = 1.9 * getParameters()$value[vs[2]],
              value = getParameters()$value[vs[2]],
              step = 0.1),
    ),
    column(2,
   sliderInput("V5",
              label = as.character(getParameters()$key[vs[3]]),
              min = 0.1 * getParameters()$value[vs[3]],
              max = 1.9 * getParameters()$value[vs[3]],
              value = getParameters()$value[vs[3]],
              step = 0.1),
    
    sliderInput("V6",
              label = as.character(getParameters()$key[vs[4]]),
              min = 0.1 * getParameters()$value[vs[4]],
              max = 1.9 * getParameters()$value[vs[4]],
              value = getParameters()$value[vs[4]],
              step = 0.1),
    ),
   column(2,
    sliderInput("V9",
              label = as.character(getParameters()$key[vs[5]]),
              min = 0.1 * getParameters()$value[vs[5]],
              max = 1.9 * getParameters()$value[vs[5]],
              value = getParameters()$value[vs[5]],
              step = 0.1),
    
    sliderInput("V10",
              label = as.character(getParameters()$key[vs[6]]),
              min = 0.1 * getParameters()$value[vs[6]],
              max = 1.9 * getParameters()$value[vs[6]],
              value = getParameters()$value[vs[6]],
              step = 0.1)
   )

    
           )



renderPlot({
  #i have no idea why i have to call this again...
  loadSBML("https://www.ebi.ac.uk/biomodels/model/download/BIOMD0000000010.2?filename=BIOMD0000000010_url.xml") 

  
      v_par <- (c(input$V1, input$V2,
                  input$V5, input$V6,
                  input$V9, input$V10))
      
      setParameters(key = getParameters()$key[vs],
                value = v_par)
      
      data_print <- data %>% pivot_longer(-Time, names_to = "names", values_to = "values")
      
      tc_print <- runTC(duration = 1000, dt = 1)$result %>%
        pivot_longer(-Time, names_to = "names", values_to = "values")
      
      ggplot()+
        geom_point(data = data_print, aes(x = Time, y = values, color = names))+
        geom_line(data = tc_print, aes(x = Time, y = values, color = names))
})




```
```{r, echo = FALSE}
setParameters(key = getParameters()$key, value = param_before)
```
As you can see, the model does not describe the data perfectly. You can try to get a better result and change the reaction speeds by using the slider.




# Parameter estimation
What you just did (or tried to do) was to find the parameters that make the model describe the data best. This is, what we call *Parameter Estimation*. As you could see, it was nearly impossible to find the combination of parameters that do that best. That is why we use algorithms that find the best fitting parameters.


Parameter estimation is an important topic when handling a model. In **CoRC** you have to 

  1. Built or load a model,
  2. Define an experiment (with data to be fitted)
  3. Define parameters that will be fitted
  4. Run Parameter Estimation.
  
We will go through these steps individually and explain what needs to be done as well as show visually how parameter estimation betters your fit.

# Setup:
First, we have to load the required packages. Please make sure, you have [**CoRK**](https://jpahle.github.io/CoRC/index.html) as well as [**ggplot2**](https://ggplot2.tidyverse.org/) installed before calling the library function.
```{r}
library(CoRC)
library(ggplot2)
```

## 1. Load a model
As stated above, to make a parameter estimation, you have to have a model to work on. If you want to know how to build you own model, you can [klick here](www.google.com) LINK!

In this workflow, we will instead load a SMBL-model.

```{r}
loadSBML("https://www.ebi.ac.uk/biomodels/model/download/BIOMD0000000010.2?filename=BIOMD0000000010_url.xml")
```
We can inspect the species of the model like this:
```{r}
getSpecies()
```
This works in a similar way for reactions (*getReactions()*) and parameters (*getParameters()*)

If you have **COPASI** installed, you can also have a look at the model there:
```{r}
# openCopasi()
```




## 2. Define an Experiment
Defining an experiment in **CoRC** means telling the program which data to fit and what the data actually describes.

So we first need data. It is always a good idea to take a look at your data before working with it. This way you can make sure nothing unexpected is happening.

```{r}
data <- read.table("MAPKdata1.txt", header = TRUE)

data
```
Then you have to define the experiment for COPASI. You need the data, as well as the type and mappings for the species. You can choose a weight method for your data (which prevents parameters getting fitted more closely just because they have higher values). 

Your data colums in your data file can be of type "time", "dependent" and "independent", and if you want to exclude a column you can choose "ignore".

The mapping argument in the function maps the data columns with the species in your model. In our case, the provided data is time course data, and our values are "transient concentrations". They are denoted like this: {[Species]}
Other notations are found [here]() LINK!!! Time needs to be mapped with NA.

Allowed weight methods are 'mean', 'mean_square', 'sd', and 'value_scaling'. 

```{r}
fit_experiments <- defineExperiments(
  data = data,
  type = c("time", "dependent", "dependent"),
  mapping = c(NA, "{[Mos-P]}", "{[Erk2-P]}"),
  weight_method = "mean_square"
)
```
## 3. Define Parameters
We now have to define parameters that will be fitted. 

First, let us take a look at all the parameters in the model:
```{r}
getParameters()
```
Now, we only want to fit the reaction rates (parameters with V). To make our fit parameters we need to make a list of lists with the attributes of the different parameter-estimation settings. To *define* a parameter for Parameter Estimation, we use the defineParameterEstimationParameter()-Function.


```{r}
#Wir können natürlich auch die regex etc... lösung nehmen (sehr viel eleganter), aber ich finde das hier deutlich einfacher zu verstehen.

fit_parameters <- list(
  defineParameterEstimationParameter(
    ref = "{(MAPKKK activation).V1}",
    start_value = getParameters("(MAPKKK activation).V1")$value,
    lower_bound = getParameters("(MAPKKK activation).V1")$value * 0.1,
    upper_bound = getParameters("(MAPKKK activation).V1")$value * 1.9
    ),
  defineParameterEstimationParameter(
    ref = "{(MAPKKK inactivation).V2}",
    start_value = getParameters("(MAPKKK inactivation).V2")$value,
    lower_bound = getParameters("(MAPKKK inactivation).V2")$value * 0.1,
    upper_bound = getParameters("(MAPKKK inactivation).V2")$value * 1.9
    ),
  defineParameterEstimationParameter(
    ref = "{(dephosphorylation of MAPKK-PP).V5}",
    start_value = getParameters("(dephosphorylation of MAPKK-PP).V5")$value,
    lower_bound = getParameters("(dephosphorylation of MAPKK-PP).V5")$value * 0.1,
    upper_bound = getParameters("(dephosphorylation of MAPKK-PP).V5")$value * 1.9 
    ),
  defineParameterEstimationParameter(
    ref = "{(dephosphorylation of MAPKK-P).V6}",
    start_value = getParameters("(dephosphorylation of MAPKK-P).V6")$value,
    lower_bound = getParameters("(dephosphorylation of MAPKK-P).V6")$value * 0.1,
    upper_bound = getParameters("(dephosphorylation of MAPKK-P).V6")$value * 1.9
    ),
  defineParameterEstimationParameter(
    ref = "{(dephosphorylation of MAPK-PP).V9}",
    start_value = getParameters("(dephosphorylation of MAPK-PP).V9")$value,
    lower_bound = getParameters("(dephosphorylation of MAPK-PP).V9")$value * 0.1,
    upper_bound = getParameters("(dephosphorylation of MAPK-PP).V9")$value * 1.9
    ),
  defineParameterEstimationParameter(
    ref = "{(dephosphorylation of MAPK-P).V10}",
    start_value = getParameters("(dephosphorylation of MAPK-P).V10")$value,
    lower_bound = getParameters("(dephosphorylation of MAPK-P).V10")$value * 0.1,
    upper_bound = getParameters("(dephosphorylation of MAPK-P).V10")$value * 1.9
  )
)

```
## 4. Run parameter estimation
To show how well our Parameter Estimation works, we want to print the model before and after parameter estimation. To do this, we have to *run* two Time Course Evaluations, one with the parameters now, and one with the parameters after the Parameter Estimation. 
```{r}
before <- runTimeCourse(duration = 1000, dt = 1)$result
```
After doing this, we will now actually run the Parameter Estimation. We need the [parameters](# 3. Define Parameters), [experiments](# ) with our data that will be fitted, and specify the method. We want to use the Levenberg Marquardt method but other methods are available as well. You can find a link to them [here](www.google.de)(LIIINK!!!!) 

Also, we specify that we want to update our model. This means, that all estimated parameters will be updated with the parameters of the best estimation. To compare the fit to the previous parameters we need to make sure we keep the previous fit. We already did that with our time course in the last chunk.

```{r}
result <-
  runParameterEstimation(
    parameters  = fit_parameters,
    experiments = fit_experiments,
    method = list(
      method = "LevenbergMarquardt",
      log_verbosity = 2
    ),
    update_model = TRUE
  )
```
You can have a nicely readable version of the result by using the str() function. For space-reasons we will only take a look at the fitted values, but feel free to take a look at anything you find interesting. 
```{r}
str(result$fitted_values)
```

## 5. Visualize results
Now we have estimated and updated the parameters of our current model. To compare our old model parameters to our new, we run another time course.
```{r}
after <- runTimeCourse(duration = 1000, dt = 1)$result
```
We will use ggplot for visualizing our results. If you have never worked with ggplot, this way to define a plot will look unusual to you. You can find some great reference to learn about plotting with **R** and **ggplot** [here](www.google.com) (LIIINK!)

We first want to plot our expermental data, as well as two time courses (before and after) for Erk2-P and Mos-P. 
```{r}
Erk2P <- 
  ggplot(mapping = aes(x = Time, y = `Erk2-P`)) +
  geom_point(data = data, aes(y = Erk2.P, color = "experimental")) +
  geom_line (data = before, aes(color = "before")) +
  geom_line (data = after, aes(color = "after"))

MosP <-
  ggplot(mapping = aes(x = Time, y = `Mos-P`)) +
  geom_point(data = data, aes(y = Mos.P, color = "experimental")) +
  geom_line (data = before, aes(color = "before")) +
  geom_line (data = after, aes(color = "after"))
```
At the end, our result for Erk2-P
```{r}
Erk2P
```
as well as our result for Mos-P
```{r}
MosP
```
show, how well the Parameter Estimation was able to fit our model to the data.

At the end, we can *unload* our model, to free some memory. 

```{r}
unloadModel()
```
