---
title: "Optimization"
author: "Johanna Daas"
output: html_document
---

This document follows closely the [Mendes 2009 paper](https://doi.org/10.1007/978-1-59745-525-1_2)[^1] on **COPASI** use cases.

If we want to optimize something, we either want to *minimize* or *maximize* a specific task value.

# Setup
First, we have to load **CoRC** and **tidyverse**. Make sure you have these packages downloaded.

```{r, message = FALSE}
library(CoRC)
library(tidyverse)
```

# Loading the model
We will work with model [Nr. 23 in BioModels](https://www.ebi.ac.uk/biomodels/BIOMD0000000023)[^2], which is a simulation of analyzing sucrose accumulation in sugar cane (Rohwer 2001). 

```{r}
loadSBML("https://www.ebi.ac.uk/biomodels/model/download/BIOMD0000000023?filename=BIOMD0000000023_url.xml")
```
We will first take a look at the reactions:
```{r}
getReactions()
```
Of interest to us are reactions *v11* (accumulation of sucrose in vacuoles) and *v9* (hydrolysis of sucrose), which decreases our overall productivity.

We can see the behavior of these two species over time in this plot:
```{r, echo = FALSE}
tc1 <- runTC(duration = 1000, dt = 1)$result %>% 
  pivot_longer(-Time, names_to = "names", values_to = "values")
ggplot(data = tc1)+
  geom_line(aes(x = Time, y = values, color = names))

```

# The objective function

We want to maximize our productivity, which we can define as the ratio of fluxes of accumulation over hydrolysis.  $J_{v11}/J_{v9} $. For our optimization algorithms it is necessary to define our optimization goal as a minimum: we want to minimize $J_{v9}/J_{v11}$

What we just defined is called an *objective function*.

In **CoRC** we can define the objective function like this:
```{r}
objf <- paste0(reaction("(v9)", reference = "Flux"), "/", reaction("(v11)", reference = "Flux"))
getValue(objf)
```

# The parameters

Now we have to think about, what we are able to change to reach the minimum possible value for our objective function. We can assume for this teaching example that we are able to manipulate the steady state levels of our enzymes in reactions *v1*, *v2*, *v3*, *v4* and *v5*. 

We have to tell **CoRC** about our optimization parameters like this:
We could also specify our parameters more closely, e.g. give them a specific starting value or bounds on how far the estimation is allowed to search. We will say that we can downregulate an enzyme by 50% and overexpress it by 400%. The start values are supposed to be the current values in our model.
```{r}
make_opt_param <- function(name) {
  value_ref <- parameter_strict(name, reference = "Value")
  value <- getValue(value_ref)
  defineOptimizationParameter(ref = value_ref,
                              start_value = value,
                              lower_bound = 0.5 * value,
                              upper_bound = 4 * value)
}

parameters <- lapply(c("(v1).Vmax1", "(v2).Vmax2", "(v3).Vmax3", "(v4).Vmax4", "(v5).Vmax5"), make_opt_param)
```

# Optimization method
Now we have to choose which optimization method we will use for optimization. For our first try we will use *Truncated Newton*. There are a lot of different methods available in **CoRC** which you can find in the documentation of the runOptimization() function. 
```{r}
method <- 'TruncatedNewton'
```

# Optimization
Now we have all elements we need for our optimization routine. We still need to specify a few arguments in our function:
* subtask: Our subtask is optimization. We could also run a Steady State Analysis or a Scan with this function
* randomize_start_values: We just took the time specifying where our start values are so we don't want to randomize them all again. If we think we always find a local minimum instead of a global one, it might be helpful to randomize the start values.
* update_model: We will save our current parameter values, so we can update the model in this function and not lose them.

```{r}
par_before <- getParameters()$value

result <- runOptimization(expression = objf,
                subtask = 'steadyState',
                randomize_start_values = FALSE,
                update_model = TRUE,
                parameters = parameters,
                method = method)
result$main$objective_value
result$parameters
```
Our new model with the updated parameter values looks like this:
```{r, echo = FALSE}
tc <- runTC(duration = 1000, dt = 1)$result %>% 
  pivot_longer(-Time, names_to = "names", values_to = "values")
ggplot()+
  geom_line(data = tc1, linetype = "dashed", aes(x = Time, y = values, color = names))+
  geom_line(data = tc, aes(x = Time, y = values, color = names))
```
The dashed lines where from the timecourse before the optimization, so we can see that our optimization routine worked!

## References
[^1]:  Mendes P., Hoops S., Sahle S., Gauges R., Dada J., Kummer U. (2009) Computational Modeling of Biochemical Networks Using COPASI. In: Maly I. (eds) Systems Biology. Methods in Molecular Biology (Methods and Protocols), vol 500. Humana Press. https://doi.org/10.1007/978-1-59745-525-1_2
[^2]: Rohwer, Johann M., and Frederik C. Botha. "Analysis of sucrose accumulation in the sugar cane culm on the basis of in vitro kinetic data." Biochemical Journal 358.2 (2001): 437-445.